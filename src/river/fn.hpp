//
// Copyright (c) 2020-2020 Uy Ha (hchanuy at gmail dot com)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
#ifndef RIVER_FN
#define RIVER_FN

#include <type_traits>

namespace river {
template <typename... Ts>
struct type_list {};
template <template <typename...> class... Ts>
struct higher_order_type_list {};

enum class FnType {
  invocable,
  free_fn_ptr,
  member_fn_ptr,
  member_var_ptr,
};

namespace detail {
template <typename>
struct Fail : std::false_type {};

template <typename T>
constexpr auto fail_v = Fail<T>::value;

template <typename T>
struct strip_qualifier {
  using type = std::remove_cv_t<std::remove_reference_t<T>>;
};
template <typename T>
using strip_qualifier_t = typename strip_qualifier<T>::type;

template <typename T>
struct fn_trait_impl {
  static_assert(fail_v<T>, "Could not deduce the trait of the given type");
};

template <typename R, typename... Args>
struct fn_trait_impl<R (*)(Args...)> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::free_fn_ptr;
  using return_t                    = R;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename... Args>
struct fn_trait_impl<R (*)(Args...) noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::free_fn_ptr;
  using return_t                    = R;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T>
struct fn_trait_impl<R(T::*)> {
  static constexpr FnType type = FnType::member_var_ptr;
  using return_t               = R;
  using object_t               = T;
  using arguments              = type_list<>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...)> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) &> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T &;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) &&> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T &&;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const &> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const &;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const &&> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const &&;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) volatile> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T volatile;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) volatile &> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T volatile &;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) volatile &&> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T volatile &&;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const volatile> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const volatile;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const volatile &> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const volatile &;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const volatile &&> {
  static constexpr auto is_noexcept = false;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const volatile &&;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) & noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T &;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) && noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T &&;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const & noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const &;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const && noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const &&;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) volatile noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T volatile;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) volatile & noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T volatile &;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) volatile && noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T volatile &&;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const volatile noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const volatile;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const volatile & noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const volatile &;
  using arguments                   = type_list<Args...>;
};

template <typename R, typename T, typename... Args>
struct fn_trait_impl<R (T::*)(Args...) const volatile && noexcept> {
  static constexpr auto is_noexcept = true;
  static constexpr FnType type      = FnType::member_fn_ptr;
  using return_t                    = R;
  using object_t                    = T const volatile &&;
  using arguments                   = type_list<Args...>;
};

template <typename Fn>
struct invocable_trait_impl {
private:
  using call_op_trait = fn_trait_impl<decltype(&Fn::operator())>;

public:
  static constexpr auto is_noexcept = call_op_trait::is_noexcept;
  static constexpr FnType type      = FnType::invocable;
  using return_t                    = typename call_op_trait::return_t;
  using object_t                    = typename call_op_trait::object_t;
  using arguments                   = typename call_op_trait::arguments;
};

template <typename Fn>
struct has_call_op {
private:
  template <typename Invocable>
  static constexpr std::true_type call(decltype(&Invocable::operator()));
  template <typename>
  static constexpr std::false_type call(...);

public:
  static constexpr auto value = decltype(call<Fn>(0))::value;
};

template <typename Fn>
constexpr auto has_call_op_v = has_call_op<Fn>::value;
} // namespace detail

template <typename T>
using fn_trait = std::conditional_t<detail::has_call_op_v<detail::strip_qualifier_t<T>>,
                                    detail::invocable_trait_impl<detail::strip_qualifier_t<T>>,
                                    detail::fn_trait_impl<detail::strip_qualifier_t<T>>>;
template <auto f>
using fn_trait_of = fn_trait<decltype(f)>;

namespace detail {
template <typename T>
constexpr T &&forward(typename std::remove_reference<T>::type &t) noexcept {
  return static_cast<T &&>(t);
}
template <typename T>
constexpr T &&forward(typename std::remove_reference<T>::type &&t) noexcept {
  static_assert(!std::is_lvalue_reference_v<T>);
  return static_cast<T &&>(t);
}

template <typename T>
struct add_ref {
  using type = T &;
};
template <typename T>
struct add_ref<T &&> {
  using type = T &&;
};
template <typename T>
using add_ref_t = typename add_ref<T>::type;

template <auto fn, FnType callable_type = fn_trait_of<fn>::type, typename Args = typename fn_trait_of<fn>::arguments>
struct fn_impl;

template <auto fn, typename... Args>
struct fn_impl<fn, FnType::invocable, type_list<Args...>> {
  constexpr auto operator()(Args... args) const noexcept(fn_trait_of<fn>::is_noexcept) -> decltype(auto) {
    return fn(detail::forward<Args>(args)...);
  }
};
template <auto fn, typename... Args>
struct fn_impl<fn, FnType::free_fn_ptr, type_list<Args...>> {
  constexpr auto operator()(Args... args) const noexcept(fn_trait_of<fn>::is_noexcept) -> decltype(auto) {
    return fn(detail::forward<Args>(args)...);
  }
};
template <auto fn, typename... Args>
struct fn_impl<fn, FnType::member_fn_ptr, type_list<Args...>> {
  constexpr auto operator()(add_ref_t<typename fn_trait_of<fn>::object_t> object, Args... args) const
      noexcept(fn_trait_of<fn>::is_noexcept) -> decltype(auto) {
    return (detail::forward<decltype(object)>(object).*fn)(detail::forward<Args>(args)...);
  }
};
template <auto fn>
struct fn_impl<fn, FnType::member_var_ptr, type_list<>> {
  constexpr auto operator()(add_ref_t<typename fn_trait_of<fn>::object_t> object) const noexcept -> decltype(auto) {
    return object.*fn;
  }
};

template <auto fn, FnType callable_type = fn_trait_of<fn>::type, typename Args = typename fn_trait_of<fn>::arguments>
struct over_fn_impl : fn_impl<fn, callable_type, Args> {
  using fn_impl<fn, callable_type, Args>::operator();
};
template <auto fn, typename... Args>
struct over_fn_impl<fn, FnType::member_fn_ptr, type_list<Args...>> {
  template <typename T>
  constexpr auto operator()(T &&object, Args... args) const noexcept(fn_trait_of<fn>::is_noexcept) -> decltype(auto) {
    return (detail::forward<decltype(object)>(object).*fn)(detail::forward<Args>(args)...);
  }
};
template <auto fn>
struct over_fn_impl<fn, FnType::member_var_ptr, type_list<>> {
  template <typename T>
  auto operator()(T &&object) const noexcept -> decltype(auto) {
    static_assert(std::is_same_v<strip_qualifier_t<T>, typename fn_trait_of<fn>::object_t>);
    return detail::forward<T>(object).*fn;
  }
};
} // namespace detail

template <auto f>
using fn = detail::fn_impl<f>;
template <auto f>
using over_fn = detail::over_fn_impl<f>;

template <typename F, FnType = fn_trait<F>::type, typename Args = typename fn_trait<F>::arguments>
struct Fn;

template <typename Invocable>
struct Fn<Invocable, FnType::invocable> : Invocable {
  using Invocable::Invocable;
  using Invocable::operator();

  constexpr Fn() = default;

  explicit constexpr Fn(Invocable const &fn)
      : Invocable{fn} {}
  explicit constexpr Fn(Invocable &&fn)
      : Invocable{static_cast<Invocable &&>(fn)} {}
};
template <typename Ptr, typename... Args>
struct Fn<Ptr, FnType::free_fn_ptr, type_list<Args...>> {
  Ptr ptr;

  constexpr auto operator()(Args... args) const noexcept(fn_trait<Ptr>::is_noexcept) -> decltype(auto) {
    return ptr(detail::forward<Args>(args)...);
  }
};
template <typename Ptr, typename... Args>
struct Fn<Ptr, FnType::member_fn_ptr, type_list<Args...>> {
  Ptr ptr;

  constexpr auto operator()(detail::add_ref_t<typename fn_trait<Ptr>::object_t> object, Args... args) const
      noexcept(noexcept((detail::forward<decltype(object)>(object).*ptr)(detail::forward<Args>(args)...)))
          -> decltype(auto) {
    return (detail::forward<decltype(object)>(object).*ptr)(detail::forward<decltype(args)>(args)...);
  }
};
template <typename Ptr>
struct Fn<Ptr, FnType::member_var_ptr, type_list<>> {
  Ptr ptr;

  constexpr auto operator()(detail::add_ref_t<typename fn_trait<Ptr>::object_t> object) const noexcept
      -> decltype(auto) {
    return object.*ptr;
  }
};

template <typename T>
Fn(T) -> Fn<T>;

template <typename F, FnType type = fn_trait<F>::type, typename Args = typename fn_trait<F>::arguments>
struct OverFn : Fn<F, type, Args> {
  using Fn<F, type, Args>::Fn;
  using Fn<F, type, Args>::operator();
};

template <typename Ptr, typename... Args>
struct OverFn<Ptr, FnType::member_fn_ptr, type_list<Args...>> {
  Ptr ptr;

  template <typename T>
  constexpr auto operator()(T &&object, Args... args) const
      noexcept(noexcept((detail::forward<T>(object).*ptr)(detail::forward<decltype(args)>(args)...)))
          -> decltype(auto) {
    return (detail::forward<T>(object).*ptr)(detail::forward<decltype(args)>(args)...);
  }
};

template <typename Ptr>
struct OverFn<Ptr, FnType::member_var_ptr> : Fn<Ptr, FnType::member_var_ptr> {
  Ptr ptr;

  template <typename T>
  constexpr auto operator()(T &&object) const noexcept -> decltype(auto) {
    return detail::forward<T>(object).*ptr;
  }
};

template <typename F>
OverFn(F) -> OverFn<F>;
} // namespace river

#endif
