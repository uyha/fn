// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#pragma once
#include <type_traits>

#ifndef FN_ENABLE_OVERLOAD
#define FN_ENABLE_OVERLOAD 1
#endif

#if FN_NO_PROPAGATE_NOEXCEPT
#define FN_NOEXCEPT
#else
#define FN_NOEXCEPT noexcept
#endif

namespace river {
template <typename T>
struct type_identity {
  using type = T;
};
template <typename T>
using type_identity_t = typename type_identity<T>::type;

template <typename T>
struct remove_noexcept : type_identity<T> {};
template <typename R, typename... Args>
struct remove_noexcept<R(Args...) noexcept> : type_identity<R(Args...)> {};
template <typename R, typename... Args>
struct remove_noexcept<R (*)(Args...) noexcept> : type_identity<R (*)(Args...)> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) noexcept> : type_identity<R (T::*)(Args...)> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) const noexcept>
    : type_identity<R (T::*)(Args...) const> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) volatile noexcept>
    : type_identity<R (T::*)(Args...) volatile> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) const volatile noexcept>
    : type_identity<R (T::*)(Args...) const volatile> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) &noexcept> : type_identity<R (T::*)(Args...) &> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) const &noexcept>
    : type_identity<R (T::*)(Args...) const &> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) volatile &noexcept>
    : type_identity<R (T::*)(Args...) volatile &> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) const volatile &noexcept>
    : type_identity<R (T::*)(Args...) const volatile &> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) &&noexcept> : type_identity<R (T::*)(Args...) &&> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) const &&noexcept>
    : type_identity<R (T::*)(Args...) const &&> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) volatile &&noexcept>
    : type_identity<R (T::*)(Args...) volatile &&> {};
template <typename R, typename T, typename... Args>
struct remove_noexcept<R (T::*)(Args...) const volatile &&noexcept>
    : type_identity<R (T::*)(Args...) const volatile &&> {};
template <typename T>
using remove_noexcept_t = typename remove_noexcept<T>::type;

template <typename T>
struct is_noexcept : std::bool_constant<!std::is_same_v<remove_noexcept_t<T>, T>> {};
template <typename T>
constexpr auto is_noexcept_v = is_noexcept<T>::value;

template <typename T>
struct remove_const : type_identity<T> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const> : type_identity<R (T::*)(Args...)> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const volatile>
    : type_identity<R (T::*)(Args...) volatile> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const noexcept>
    : type_identity<R (T::*)(Args...) noexcept> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const volatile noexcept>
    : type_identity<R (T::*)(Args...) volatile noexcept> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const &> : type_identity<R (T::*)(Args...) &> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const volatile &>
    : type_identity<R (T::*)(Args...) volatile &> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const &noexcept>
    : type_identity<R (T::*)(Args...) &noexcept> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const volatile &noexcept>
    : type_identity<R (T::*)(Args...) volatile &noexcept> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const &&> : type_identity<R (T::*)(Args...) &&> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const volatile &&>
    : type_identity<R (T::*)(Args...) volatile &&> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const &&noexcept>
    : type_identity<R (T::*)(Args...) &&noexcept> {};
template <typename R, typename T, typename... Args>
struct remove_const<R (T::*)(Args...) const volatile &&noexcept>
    : type_identity<R (T::*)(Args...) volatile &&noexcept> {};
template <typename T>
using remove_const_t = typename remove_const<T>::type;

template <typename T>
struct is_const : std::bool_constant<!std::is_same_v<remove_const_t<T>, T>> {};
template <typename T>
constexpr auto is_const_v = is_const<T>::value;

namespace detail {
template <typename T>
constexpr T &&forward(typename std::remove_reference<T>::type &t) noexcept {
  return static_cast<T &&>(t);
}
template <typename T>
constexpr T &&forward(typename std::remove_reference<T>::type &&t) noexcept {
  static_assert(!std::is_lvalue_reference_v<T>);
  return static_cast<T &&>(t);
}

template <typename T, type_identity_t<T>>
struct FnImpl;

// region Free functions
template <typename R, typename... Args, R (*fn)(Args...)>
struct FnImpl<R (*)(Args...), fn> {
  constexpr R operator()(Args... args) const {
    return fn(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename... Args, R (*fn)(Args...) noexcept>
struct FnImpl<R (*)(Args...) noexcept, fn> {
  constexpr R operator()(Args... args) const FN_NOEXCEPT {
    return fn(river::detail::forward<Args>(args)...);
  }
};
// endregion

// region Member functions
template <typename R, typename T, typename... Args, R (T::*fn)(Args...)>
struct FnImpl<R (T::*)(Args...), fn> {
  constexpr R operator()(T &obj, Args... args) const {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
#if FN_ENABLE_OVERLOAD
  constexpr R operator()(T &&obj, Args... args) const {
    return (river::detail::forward<decltype(obj)>(obj).*fn)(river::detail::forward<Args>(args)...);
  }
#endif
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const>
struct FnImpl<R (T::*)(Args...) const, fn> {
  constexpr R operator()(T const &obj, Args... args) const {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) volatile>
struct FnImpl<R (T::*)(Args...) volatile, fn> {
  constexpr R operator()(T volatile &obj, Args... args) const {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
#if FN_ENABLE_OVERLOAD
  constexpr R operator()(T volatile &&obj, Args... args) const {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
#endif
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const volatile>
struct FnImpl<R (T::*)(Args...) const volatile, fn> {
  constexpr R operator()(T const volatile &obj, Args... args) const {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
#if FN_ENABLE_OVERLOAD
  constexpr R operator()(T const volatile &&obj, Args... args) const {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
#endif
};

template <typename R, typename T, typename... Args, R (T::*fn)(Args...) &>
struct FnImpl<R (T::*)(Args...) &, fn> {
  constexpr R operator()(T &obj, Args... args) const {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const &>
struct FnImpl<R (T::*)(Args...) const &, fn> {
  constexpr R operator()(T const &obj, Args... args) const {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) volatile &>
struct FnImpl<R (T::*)(Args...) volatile &, fn> {
  constexpr R operator()(T volatile &obj, Args... args) const {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const volatile &>
struct FnImpl<R (T::*)(Args...) const volatile &, fn> {
  constexpr R operator()(T const volatile &obj, Args... args) const {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
};

template <typename R, typename T, typename... Args, R (T::*fn)(Args...) &&>
struct FnImpl<R (T::*)(Args...) &&, fn> {
  constexpr R operator()(T &&obj, Args... args) const {
    return (river::detail::forward<decltype(obj)>(obj).*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const &&>
struct FnImpl<R (T::*)(Args...) const &&, fn> {
  constexpr R operator()(T const &&obj, Args... args) const {
    return (river::detail::forward<decltype(obj)>(obj).*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) volatile &&>
struct FnImpl<R (T::*)(Args...) volatile &&, fn> {
  constexpr R operator()(T volatile &&obj, Args... args) const {
    return (river::detail::forward<decltype(obj)>(obj).*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const volatile &&>
struct FnImpl<R (T::*)(Args...) const volatile &&, fn> {
  constexpr R operator()(T const volatile &&obj, Args... args) const {
    return (river::detail::forward<decltype(obj)>(obj).*fn)(river::detail::forward<Args>(args)...);
  }
};

template <typename R, typename T, typename... Args, R (T::*fn)(Args...) noexcept>
struct FnImpl<R (T::*)(Args...) noexcept, fn> {
  constexpr R operator()(T &obj, Args... args) const FN_NOEXCEPT {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
#if FN_ENABLE_OVERLOAD
  constexpr R operator()(T &&obj, Args... args) const FN_NOEXCEPT {
    return (river::detail::forward<decltype(obj)>(obj).*fn)(river::detail::forward<Args>(args)...);
  }
#endif
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const noexcept>
struct FnImpl<R (T::*)(Args...) const noexcept, fn> {
  constexpr R operator()(T const &obj, Args... args) const FN_NOEXCEPT {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) volatile noexcept>
struct FnImpl<R (T::*)(Args...) volatile noexcept, fn> {
  constexpr R operator()(T volatile &obj, Args... args) const FN_NOEXCEPT {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
#if FN_ENABLE_OVERLOAD
  constexpr R operator()(T volatile &&obj, Args... args) const FN_NOEXCEPT {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
#endif
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const volatile noexcept>
struct FnImpl<R (T::*)(Args...) const volatile noexcept, fn> {
  constexpr R operator()(T const volatile &obj, Args... args) const FN_NOEXCEPT {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
#if FN_ENABLE_OVERLOAD
  constexpr R operator()(T const volatile &&obj, Args... args) const FN_NOEXCEPT {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
#endif
};

template <typename R, typename T, typename... Args, R (T::*fn)(Args...) &noexcept>
struct FnImpl<R (T::*)(Args...) &noexcept, fn> {
  constexpr R operator()(T &obj, Args... args) const FN_NOEXCEPT {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const &noexcept>
struct FnImpl<R (T::*)(Args...) const &noexcept, fn> {
  constexpr R operator()(T const &obj, Args... args) const FN_NOEXCEPT {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) volatile &noexcept>
struct FnImpl<R (T::*)(Args...) volatile &noexcept, fn> {
  constexpr R operator()(T volatile &obj, Args... args) const FN_NOEXCEPT {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const volatile &noexcept>
struct FnImpl<R (T::*)(Args...) const volatile &noexcept, fn> {
  constexpr R operator()(T const volatile &obj, Args... args) const FN_NOEXCEPT {
    return (obj.*fn)(river::detail::forward<Args>(args)...);
  }
};

template <typename R, typename T, typename... Args, R (T::*fn)(Args...) &&noexcept>
struct FnImpl<R (T::*)(Args...) &&noexcept, fn> {
  constexpr R operator()(T &&obj, Args... args) const FN_NOEXCEPT {
    return (river::detail::forward<decltype(obj)>(obj).*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const &&noexcept>
struct FnImpl<R (T::*)(Args...) const &&noexcept, fn> {
  constexpr R operator()(T const &&obj, Args... args) const FN_NOEXCEPT {
    return (river::detail::forward<decltype(obj)>(obj).*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) volatile &&noexcept>
struct FnImpl<R (T::*)(Args...) volatile &&noexcept, fn> {
  constexpr R operator()(T volatile &&obj, Args... args) const FN_NOEXCEPT {
    return (river::detail::forward<decltype(obj)>(obj).*fn)(river::detail::forward<Args>(args)...);
  }
};
template <typename R, typename T, typename... Args, R (T::*fn)(Args...) const volatile &&noexcept>
struct FnImpl<R (T::*)(Args...) const volatile &&noexcept, fn> {
  constexpr R operator()(T const volatile &&obj, Args... args) const FN_NOEXCEPT {
    return (river::detail::forward<decltype(obj)>(obj).*fn)(river::detail::forward<Args>(args)...);
  }
};

template <typename R, typename T, R(T::*fn)>
struct FnImpl<std::enable_if_t<!std::is_member_function_pointer_v<R(T::*)>, R(T::*)>, fn> {
  constexpr R operator()(T const &obj) const {
    return obj.*fn;
  }
#if FN_ENABLE_OVERLOAD
  constexpr R operator()(T const volatile &obj) const {
    return obj.*fn;
  }
  constexpr R operator()(T const volatile &&obj) const {
    return obj.*fn;
  }
#endif
};
// endregion

} // namespace detail

template <auto fp>
using fn = detail::FnImpl<decltype(fp), fp>;
} // namespace river