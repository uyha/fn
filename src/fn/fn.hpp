//
// Copyright (c) 2020-2020 Uy Ha (hchanuy at gmail dot com)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#pragma once
#include <type_traits>

namespace river {
template <typename... Ts>
struct type_list {};

// region fn_trait
template <typename T>
struct fn_trait;
template <typename R, typename... Args>
struct fn_trait<R (*)(Args...)> {
  static constexpr bool is_free_fn   = true;
  static constexpr bool is_member_fn = false;
  static constexpr bool is_noexcept  = false;

  using return_type = R;
  using arguments   = type_list<Args...>;
};
template <typename R, typename... Args>
struct fn_trait<R (*)(Args...) noexcept> {
  static constexpr bool is_free_fn   = true;
  static constexpr bool is_member_fn = false;
  static constexpr bool is_noexcept  = true;

  using return_type = R;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...)> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) volatile> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const volatile> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) volatile noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const volatile noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) &> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = true;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const &> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = true;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) volatile &> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = true;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const volatile &> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = true;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) &noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = true;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const &noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = true;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) volatile &noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = true;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const volatile &noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = true;
  static constexpr bool is_rvalue_ref = false;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) &&> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = true;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const &&> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = true;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) volatile &&> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = true;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const volatile &&> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = true;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = false;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) &&noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = true;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const &&noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = true;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = false;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) volatile &&noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = true;
  static constexpr bool is_const      = false;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
template <typename R, typename T, typename... Args>
struct fn_trait<R (T::*)(Args...) const volatile &&noexcept> {
  static constexpr bool is_free_fn    = false;
  static constexpr bool is_member_fn  = true;
  static constexpr bool is_lvalue_ref = false;
  static constexpr bool is_rvalue_ref = true;
  static constexpr bool is_const      = true;
  static constexpr bool is_volatile   = true;
  static constexpr bool is_noexcept   = true;

  using return_type = R;
  using object_type = T;
  using arguments   = type_list<Args...>;
};
// endregion

namespace detail {
template <typename T>
constexpr T &&forward(typename std::remove_reference<T>::type &t) noexcept {
  return static_cast<T &&>(t);
}
template <typename T>
constexpr T &&forward(typename std::remove_reference<T>::type &&t) noexcept {
  static_assert(!std::is_lvalue_reference_v<T>);
  return static_cast<T &&>(t);
}

template <typename T>
struct simple_mapper {
private:
  static constexpr auto is_const    = fn_trait<T>::is_const;
  static constexpr auto is_volatile = fn_trait<T>::is_volatile;
  static const auto is_rvalue_ref   = fn_trait<T>::is_rvalue_ref;

  using object_type = typename fn_trait<T>::object_type;

public:
  using type = std::conditional_t<
      is_const && is_volatile,
      std::
          conditional_t<is_rvalue_ref, object_type const volatile &&, object_type const volatile &>,
      std::conditional_t<
          is_volatile,
          std::conditional_t<is_rvalue_ref, object_type volatile &&, object_type volatile &>,
          std::conditional_t<
              is_const,
              std::conditional_t<is_rvalue_ref, object_type const &&, object_type const &>,
              std::conditional_t<is_rvalue_ref, object_type &&, object_type &>>>>;
};
template <typename T>
using simple_mapper_t = typename simple_mapper<T>::type;

template <typename T,
          T fn,
          template <typename>
          class mapper,
          bool is_free_fn = fn_trait<T>::is_free_fn,
          typename Args   = typename fn_trait<T>::arguments>
struct FnImpl;
template <typename T, T fn, template <typename> class object_mapper, typename... Args>
struct FnImpl<T, fn, object_mapper, true, type_list<Args...>> {
  auto operator()(Args... args) const noexcept(fn_trait<T>::is_noexcept) ->
      typename fn_trait<T>::return_type {
    return fn(detail::forward<Args>(args)...);
  }
};
template <typename T, T fn, template <typename> class object_mapper, typename... Args>
struct FnImpl<T, fn, object_mapper, false, type_list<Args...>> {
  auto operator()(object_mapper<T> object, Args... args) const noexcept(fn_trait<T>::is_noexcept) ->
      typename fn_trait<T>::return_type {
    return (detail::forward<decltype(object)>(object).*fn)(detail::forward<Args>(args)...);
  }
};
} // namespace detail
template <auto f, template <typename> class... mappers_t>
struct overloading_fn : detail::FnImpl<decltype(f), f, mappers_t>... {
  using detail::FnImpl<decltype(f), f, mappers_t>::operator()...;
};
template <auto f>
struct fn : detail::FnImpl<decltype(f), f, detail::simple_mapper_t> {
  using detail::FnImpl<decltype(f), f, detail::simple_mapper_t>::operator();
};
} // namespace river